Rust 所有权课堂笔记

首先，rust 所有权

它有三条基本法则

* 任何资源都有一个所有者
* 任何一个时刻，只有一个所有者
* 当所有者在的作用域被释放时，值会被释放掉；



在处理不同类型的时候，所有权法则有所不同，

* 当处理 primitive 类型的时候（char，bool，uint，f32/f64，或者这些原生类型的 tuple ），默认是 copy 语义，因为这些类型编译时大小已知，此时这些数据存储在栈帧上；
* 在处理其他类型的时候，默认都是 move 语义， 比如 String；



其次，不可变引用

```rust
let a = 10u32;
let b = &a
```

这里有如下几个规则

* 不可变引用本质是一个 4个字节的变量，存储被引用变量的描述信息，
* 无论加多少层级的引用，都可以成功找到被引用的变量；
* 引用的生命周期小于变量本身的生命周期；
* 如果引用没有被使用，则会被优化失效，”出生即死亡“；
* 引用的生命周期从它被定义开始，到它不再被使用；



最后，可变引用，

```rust
let mut a = 10u32;
let c = &mut a;
```

这里有如下几个规则

* 对于同一变量，在同一作用域下，可变引用与不可变引用不可同时存在；
* 这里并不遵循 {} 的所有权释放规则，而是从它不再被使用开始，因此在同一个 {} 内，可以同时存在可变引用与不可变引用，但是他们不能 overlap。



拿函数举例说明所有权的使用：

* 在函数中，当函数的入参是变量而非引用时，变量所有权会 move 到函数内部，随着函数的结束，而被释放；
* 当入参是引用时，随着函数结束，引用被释放；
* 当入参是可变引用时，随着函数结束，引用被释放，而且根据惯例，函数内会发生修改该变量的操作；
* 当函数返回某个变量时，其所有权从函数内随着返回，给到了 caller。
* 不可以返回某个变量的引用给 caller ，因为变量会随着函数释放被释放；



